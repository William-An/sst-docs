"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8064],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>h});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function m(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},l=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),p=c(r),u=a,h=p["".concat(s,".").concat(u)]||p[u]||d[u]||i;return r?n.createElement(h,o(o({ref:t},l),{},{components:r})):n.createElement(h,o({ref:t},l))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=u;var m={};for(var s in t)hasOwnProperty.call(t,s)&&(m[s]=t[s]);m.originalType=e,m[p]="string"==typeof e?e:a,o[1]=m;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},81150:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>m,toc:()=>c});var n=r(87462),a=(r(67294),r(3905));const i={title:"memHierarchy"},o=void 0,m={unversionedId:"elements/memHierarchy/intro",id:"elements/memHierarchy/intro",title:"memHierarchy",description:"The memHierarchy library is a collection of cache, scratchpad, directory, and memory components that can be used to build memory systems. The components are generally designed to be interoperable. The library implements SST's StandardMemory interface for interfacing between endpoints (CPU, GPU, other accelerator, etc.) and the memHierarchy memory system. Additionally, memHierarchy components can be connected to each other and endpoints via both both raw SST links and network libraries that implement the SimpleNetwork interface.",source:"@site/../docs/elements/memHierarchy/intro.md",sourceDirName:"elements/memHierarchy",slug:"/elements/memHierarchy/intro",permalink:"/sst-docs/docs/elements/memHierarchy/intro",draft:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/elements/memHierarchy/intro.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1695940750,formattedLastUpdatedAt:"Sep 28, 2023",frontMatter:{title:"memHierarchy"},sidebar:"elements",previous:{title:"macro",permalink:"/sst-docs/docs/elements/macro/intro"},next:{title:"mercury",permalink:"/sst-docs/docs/elements/mercury/intro"}},s={},c=[{value:"Required dependencies",id:"required-dependencies",level:3},{value:"Optional dependencies",id:"optional-dependencies",level:3}],l={toc:c},p="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"memHierarchy")," library is a collection of cache, scratchpad, directory, and memory components that can be used to build memory systems. The components are generally designed to be interoperable. The library implements SST's ",(0,a.kt)("a",{parentName:"p",href:"/sst-docs/docs/core/iface/StandardMem/class"},(0,a.kt)("inlineCode",{parentName:"a"},"StandardMemory"))," interface for interfacing between endpoints (CPU, GPU, other accelerator, etc.) and the memHierarchy memory system. Additionally, memHierarchy components can be connected to each other and endpoints via both both raw SST links and network libraries that implement the ",(0,a.kt)("a",{parentName:"p",href:"/sst-docs/docs/core/iface/SimpleNetwork/class"},(0,a.kt)("inlineCode",{parentName:"a"},"SimpleNetwork"))," interface."),(0,a.kt)("admonition",{title:"At a Glance",type:"note"},(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("strong",{parentName:"p"},"Source Code:")," ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sstsimulator/sst-elements/tree/master/src/sst/elements/memHierarchy"},"sst-elements/.../memHierarchy")," ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"SST Name:")," ",(0,a.kt)("inlineCode",{parentName:"p"},"memHierarchy")," ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"Maturity Level:")," Mature (3) ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"Development Path:")," Active ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("strong",{parentName:"p"},"Last Released:")," SST 13.0")),(0,a.kt)("h3",{id:"required-dependencies"},"Required dependencies"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"None")),(0,a.kt)("h3",{id:"optional-dependencies"},"Optional dependencies"),(0,a.kt)("p",null,"MemHierarchy memories can optionally use any of the following simulators in place of the included timing models for main memory, scratchpad, and other components that load a backend timing model. SST-Elements must be compiled with the appropriate ",(0,a.kt)("inlineCode",{parentName:"p"},"--with-<SIMULATOR>=/path/to/sim")," flag for the integration to be enabled. See the SST ",(0,a.kt)("a",{parentName:"p",href:"http://sst-simulator.org/SSTPages/SSTBuildAndInstall_13dot0dot0_SeriesAdditionalExternalComponents/"},"dependency build instructions")," for details."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../cramsim/intro"},"CramSim")),(0,a.kt)("li",{parentName:"ul"},"DramSim2"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https::/github.com/umd-memsys/dramsim3"},"DramSim3")),(0,a.kt)("li",{parentName:"ul"},"HBMDramSim"),(0,a.kt)("li",{parentName:"ul"},"HMCSim"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/jimstevens2001/HybridSim"},"HybridSim")),(0,a.kt)("li",{parentName:"ul"},"NVDIMMSim"),(0,a.kt)("li",{parentName:"ul"},"Ramulator")))}d.isMDXComponent=!0}}]);
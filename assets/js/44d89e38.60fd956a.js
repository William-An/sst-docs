"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[650],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>h});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(r),u=o,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||a;return r?n.createElement(h,i(i({ref:t},p),{},{components:r})):n.createElement(h,i({ref:t},p))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},8606:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>m});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],s={title:"SST_ELI_ELEMENT_VERSION",sidebar_label:"Versioning"},l=void 0,c={unversionedId:"core/eli/other/sst_eli_element_version",id:"core/eli/other/sst_eli_element_version",title:"SST_ELI_ELEMENT_VERSION",description:"This macro is used inside some of the SST registration macros to assign a version to SST objects. The version is not checked by SST and does not need to match the SST version. The macro is provided to assist element library developers with versioning and managing compatibility between libraries. The macro takes a triple of numbers which are converted to an X.Y.Z version number.",source:"@site/../docs/core/eli/other/sst_eli_element_version.md",sourceDirName:"core/eli/other",slug:"/core/eli/other/sst_eli_element_version",permalink:"/sst-docs/docs/core/eli/other/sst_eli_element_version",draft:!1,editUrl:"https://github.com/sstsimulator/docs/edit/master/docs/../docs/core/eli/other/sst_eli_element_version.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1678138197,formattedLastUpdatedAt:"Mar 6, 2023",frontMatter:{title:"SST_ELI_ELEMENT_VERSION",sidebar_label:"Versioning"},sidebar:"Core API",previous:{title:"Component Categories",permalink:"/sst-docs/docs/core/eli/other/sst_eli_category_info"},next:{title:"Export ELI",permalink:"/sst-docs/docs/core/eli/other/sst_eli_export"}},p={},m=[{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Header",id:"header",level:2}],d={toc:m},u="wrapper";function h(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)(u,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"SST_ELI_ELEMENT_VERSION(majorX, minorY, minorZ)\n")),(0,a.kt)("p",null,"This macro is used inside some of the SST registration macros to assign a version to SST objects. The version is ",(0,a.kt)("em",{parentName:"p"},"not")," checked by SST and does not need to match the SST version. The macro is provided to assist element library developers with versioning and managing compatibility between libraries. The macro takes a triple of numbers which are converted to an X.Y.Z version number."),(0,a.kt)("h2",{id:"parameters"},"Parameters"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"majorX")," (int) The major version number"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"minorY")," (int) The minor version number"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"minorZ")," (int) An additional minor version number")),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"example-1"},"Example 1"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'class example1 : public SST::Component\n{\npublic:\n\n    SST_ELI_REGISTER_COMPONENT(\n        example1,                           \n        "simpleElementExample",             \n        "example1",                         \n        SST_ELI_ELEMENT_VERSION(1,0,0),     // Version of the component will be "1.0.0"\n        "Example #2, statistics & RNG",     \n        COMPONENT_CATEGORY_UNCATEGORIZED    \n    )\n\n/* Rest of class */\n};\n\n')),(0,a.kt)("h2",{id:"header"},"Header"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/module.h> // or\n#include <sst/core/profiletool.h> // or\n#include <sst/core/module/element_python.h>\n")))}h.isMDXComponent=!0}}]);
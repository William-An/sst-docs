"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9724],{65374:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=i(74848),a=i(28453);const s={title:"Checkpoint and Restart"},r=void 0,o={id:"guides/features/checkpoint",title:"Checkpoint and Restart",description:"In SST 14, SST has begun to bring back support for checkpoint/restart. Under the checkpoint/restart infrastructure, a particular SST simulation can be checkpointed only if all of the elements it uses support checkpointing (that is, are serializable). Thus, it will be necessary for developers to add checkpointing capability to their models. The current infrastructure is experimental and has several temporary limitations described below. It was released to enable developers to start adding checkpoint support in anticipation of a fully-functional checkpoint/restart capability. We also expect that as element libraries are made checkpointable and we discover new requirements, the SST-Core support may need modifications.",source:"@site/../docs/guides/features/checkpoint.md",sourceDirName:"guides/features",slug:"/guides/features/checkpoint",permalink:"/sst-docs/docs/guides/features/checkpoint",draft:!1,unlisted:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/guides/features/checkpoint.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1716583959e3,frontMatter:{title:"Checkpoint and Restart"},sidebar:"guides",previous:{title:"Features",permalink:"/sst-docs/docs/category/features"},next:{title:"Tips and Tricks",permalink:"/sst-docs/docs/category/tips-and-tricks"}},l={},c=[{value:"Use case",id:"use-case",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Short-term temporary limitations",id:"short-term-temporary-limitations",level:3},{value:"Longer-term temporary limitations",id:"longer-term-temporary-limitations",level:3},{value:"Non-temporary limitations",id:"non-temporary-limitations",level:3},{value:"Creating a checkpoint",id:"creating-a-checkpoint",level:2},{value:"Restarting from a checkpoint",id:"restarting-from-a-checkpoint",level:2},{value:"Adding checkpoint support to SST Element libraries",id:"adding-checkpoint-support-to-sst-element-libraries",level:2},{value:"Step 1: Change Clock and Event handler functions",id:"step-1-change-clock-and-event-handler-functions",level:3},{value:"Step 2: Add a default constructor",id:"step-2-add-a-default-constructor",level:3},{value:"Step 3: Add a serialization function",id:"step-3-add-a-serialization-function",level:3},{value:"Step 4: Add the appropriate serialization macro",id:"step-4-add-the-appropriate-serialization-macro",level:3},{value:"Put it together: An example",id:"put-it-together-an-example",level:3},{value:"Advanced notes on serialization",id:"advanced-notes-on-serialization",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["In SST 14, SST has begun to bring back support for checkpoint/restart. Under the checkpoint/restart infrastructure, a particular SST simulation can be checkpointed ",(0,t.jsx)(n.em,{children:"only"})," if all of the elements it uses support checkpointing (that is, are serializable). Thus, it will be necessary for developers to add checkpointing capability to their models. The current infrastructure is experimental and has several temporary limitations described below. It was released to enable developers to start adding checkpoint support in anticipation of a fully-functional checkpoint/restart capability. We also expect that as element libraries are made checkpointable and we discover new requirements, the SST-Core support may need modifications."]}),"\n",(0,t.jsx)(n.p,{children:"This guide describes how to use checkpoint/restart, the current limitations, and how to make element libraries checkpoint-able. As checkpointing support evolves, this guide will be updated."}),"\n",(0,t.jsx)(n.h2,{id:"use-case",children:"Use case"}),"\n",(0,t.jsxs)(n.p,{children:["SST's checkpointing infrastructure is intended for a checkpoint-restart use case. For example, on machines with job scheduling infrastructure, a long-running simulation can be restarted to comply with job time limits or to address a node failure. Checkpoints are not intended to be portable across architectures or compilers. SST's serialization uses C++ ",(0,t.jsx)(n.code,{children:"typeid"}),"s which are not guaranteed to be portable."]}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.p,{children:"There are several limitations in the current implementation."}),"\n",(0,t.jsx)(n.h3,{id:"short-term-temporary-limitations",children:"Short-term temporary limitations"}),"\n",(0,t.jsx)(n.p,{children:"The following limitations are expected to be addressed in the coming months."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Checkpoint/restart is only supported for serial simulations"}),"\n",(0,t.jsx)(n.li,{children:"Statistics are not checkpointed. On restart, any previously enabled statistics will be disabled."}),"\n",(0,t.jsx)(n.li,{children:"There is no way to query whether a particular Element supports checkpointing."}),"\n",(0,t.jsx)(n.li,{children:"The target directory to write checkpoints to cannot be set."}),"\n",(0,t.jsx)(n.li,{children:"The checkpoint period must be specified in simulated time rather than real (wall) time."}),"\n",(0,t.jsx)(n.li,{children:"There are no options to limit the number of checkpoints kept."}),"\n",(0,t.jsxs)(n.li,{children:["SST serialization has support for standard C++ containers and containers of pointers but ",(0,t.jsx)(n.em,{children:"not"})," a pointer to a container."]}),"\n",(0,t.jsx)(n.li,{children:"SST interfaces (SimpleNetwork, StandardMem) have not yet been made serializable so elements using them will not be able to generate checkpoints"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"longer-term-temporary-limitations",children:"Longer-term temporary limitations"}),"\n",(0,t.jsx)(n.p,{children:"These limitations are expected to be addressed as needed and once the short-term limitations above are resolved."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Checkpoint state can, for the most part, not be altered at restart. We anticipate eventually allowing some state to be changed at restart (e.g., partitioning, parallelization).","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["An exception is that command line options governing output such as ",(0,t.jsx)(n.code,{children:"--verbose"})," and ",(0,t.jsx)(n.code,{children:"--output-directory"})," will override state set in the checkpoint."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Only the primary/default TimeVortex implementation supports checkpoint."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"non-temporary-limitations",children:"Non-temporary limitations"}),"\n",(0,t.jsx)(n.p,{children:"These are limitations that either we have not identified a path towards addressing or that we do not intend to address."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Profile points are not checkpoint-able."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-checkpoint",children:"Creating a checkpoint"}),"\n",(0,t.jsxs)(n.p,{children:["Checkpoints can be created by passing the ",(0,t.jsx)(n.code,{children:"--checkpoint-period"})," option to SST or by setting the option in the Python configuration file. In addition, a prefix can optionally be specified to customize the checkpoint filename."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'$ sst --checkpoint-period=250us configuration.py\nor\n$ sst --checkpoint-period=250us --checkpoint-prefix="simulation" configuration.py\n'})}),"\n",(0,t.jsx)(n.p,{children:"or"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'import sst\n\nsst.setProgramOption("checkpoint-period", "250us")\nsst.setProgramOption("checkpoint-prefix", "simulation") # Optional\n'})}),"\n",(0,t.jsx)(n.p,{children:"The period refers to simulated time (see limitations above) and must include units. SI-prefixes are valid."}),"\n",(0,t.jsxs)(n.p,{children:["This will produce a checkpoint every 250us (in the example).\nCheckpoints are written to the current working directory and the file name is ",(0,t.jsx)(n.code,{children:"PREFIX_TIME_ID.sstcpt"}),", if a PREFIX was provided, or ",(0,t.jsx)(n.code,{children:"checkpoint_TIME_ID.sstcpt"}),". ",(0,t.jsx)(n.code,{children:"TIME"})," is the time of the checkpoint as measured in the simulation's core time base. For most simulations, this is picoseconds. ",(0,t.jsx)(n.code,{children:"ID"})," starts at 0 for the first checkpoint and is incremented for each subsequent checkpoint. Once checkpointing parallel simulations is supported, we anticipate generating multiple files per checkpoint."]}),"\n",(0,t.jsx)(n.h2,{id:"restarting-from-a-checkpoint",children:"Restarting from a checkpoint"}),"\n",(0,t.jsxs)(n.p,{children:["To restart from a checkpoint, use the ",(0,t.jsx)(n.code,{children:"--load-checkpoint"})," option and pass the checkpoint file instead of a configuration file."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"$ sst --load-checkpoint checkpoint_250000000_0.sstcpt\n"})}),"\n",(0,t.jsx)(n.h2,{id:"adding-checkpoint-support-to-sst-element-libraries",children:"Adding checkpoint support to SST Element libraries"}),"\n",(0,t.jsx)(n.p,{children:"To support checkpointing, any object that could be part of a checkpoint needs to be serializable and provide a method for serializing and deserializing its state. Element APIs (Component, SubComponent, Module) inherit from SST's serializable class and can be made serializable by following the steps below. The same serialization engine is used both for the existing Event serialization in parallel simulations and for checkpointing. Thus, the steps are similar to the steps needed to make Events serializable. Like Event serialization, checkpointing requires data to be explicitly added to the serialization stream. Unlike Event serialization, checkpointing tracks and tags pointers to objects so that upon restart, a pointer will correctly point to the recreated object."}),"\n",(0,t.jsx)(n.p,{children:"Use these guidelines to determine how to make an object serializable:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Elements (Components, SubComponents, Modules, etc.)"}),": Follow steps 1-4 below."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Non-polymorphic classes and structs"})," Either inherit from SST's serializable class and follow steps 1-4 OR add a serialize_order function without inheriting from the serializable class (step 3 only). Non-polymorphic classes will also need a default constructor if they do not already have one. (step 2)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"All other classes"})," The easiest method is to inherit from SST's serializable class and then follow steps 1-4."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This snippet shows how to inherit from SST's serializable class."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Inheriting from SST\'s serializable class"',children:"#include <sst/core/serialization/serializable.h>\n\nclass MyClass : public SST::Core::Serialization::serializable {\n    ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-1-change-clock-and-event-handler-functions",children:"Step 1: Change Clock and Event handler functions"}),"\n",(0,t.jsxs)(n.p,{children:["The existing handler signatures are not serializable, however, the updated signatures require minimal changes. The handler type needs to be changed from ",(0,t.jsx)(n.code,{children:"Handler"})," to ",(0,t.jsx)(n.code,{children:"Handler2"})," and the function pointer needs to be moved from the function parameters into the template parameters."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"// Clock handler without metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Clock handler with metadata\nSST::Clock::HandlerBase* old_handler = \n    new SST::Clock::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Clock::HandlerBase* new_handler = \n    new SST::Clock::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n\n// Event handler without metadata\nSST::Link::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName>(this, &ComponentName::HandlerFunction); // Not serializable\nSST::Link::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction>(this); // Serializable\n\n// Event handler with metadata\nSST::Event::HandlerBase* old_handler = \n    new SST::Event::Handler<ComponentName, uint32_t>(this, &ComponentName::HandlerFunction, 0); // Not serializable\nSST::Event::HandlerBase* new_handler = \n    new SST::Event::Handler2<ComponentName, &ComponentName::HandlerFunction, uint32_t>(this, 0); // Serializable\n"})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-add-a-default-constructor",children:"Step 2: Add a default constructor"}),"\n",(0,t.jsx)(n.p,{children:"During deserialization, SST will call this constructor to create an object before populating its state from the checkpoint."}),"\n",(0,t.jsx)(n.h3,{id:"step-3-add-a-serialization-function",children:"Step 3: Add a serialization function"}),"\n",(0,t.jsxs)(n.p,{children:["SST's serializer calls ",(0,t.jsx)(n.code,{children:"serialize_order"})," on elements during both serialization and deserialization.\nAdd this function to a public section of your class definition:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title = "class.h"',children:"public:\n    // highlight-start\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    // highlight-end\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The function implementation should (1) call the base class's serialize_order if the class is inherited and (2) add ",(0,t.jsx)(n.em,{children:"all"})," class data members that need to be saved to the checkpoint. During checkpoint generation, the serializer is tracking pointers and will correctly regenerate pointers upon restart. Recall that this is ",(0,t.jsx)(n.em,{children:"not"})," true of normal event serialization during synchronization. SST provides two macros, ",(0,t.jsx)(n.code,{children:"SST_SER"})," and ",(0,t.jsx)(n.code,{children:"SST_SER_AS_PTR"})," to add data to the checkpoint. The macros are defined as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="Snippet from sst-core/src/sst/core/serialization/serializable.h"',children:"#define SST_SER(x) ser& x;\n#define SST_SER_AS_PTR(x) ser| x;\n"})}),"\n",(0,t.jsx)(n.p,{children:"The macros have been added as a longer term SST goal is to use this serialization to also provide online debugging capability and the macro allows the serializer to capture the name, address, type, and data associated with the serialized object. For now, the macro is a placeholder and by using it, developers should save themselves some rewriting later to support that debug capability."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SST_SER"})," (",(0,t.jsx)(n.code,{children:"&"}),") operator is used most commonly and adds data to the checkpoint (and loads saved data into the provided variable during restart). SST_SER is used for all pointer types and for all non-pointer data where there are no other pointers referencing it.  The ",(0,t.jsx)(n.code,{children:"SST_SER_AS_PTR"}),"(",(0,t.jsx)(n.code,{children:"|"}),") operator works only for non-pointer data and adds both the data to the checkpoint ",(0,t.jsx)(n.em,{children:"and"})," registers a pointer to the data. This operator is only required if the object being serialized is not a pointer and you have a pointer elsewhere to the object that you intend to serialize as well. Using this macro allows a serialized pointer to correctly link itself to the serialized data. Using ",(0,t.jsx)(n.code,{children:"SST_SER_AS_PTR"})," consumes both extra space in the checkpoint and adds a (small) overhead during serialization. Note, that the non-pointer data must serialize before any pointers to the data are serialized, otherwise the deserialized data will not be correct. One use case for ",(0,t.jsx)(n.code,{children:"SST_SER_AS_PTR"})," is when the data is stored in a container (such as a map or set) and there are other pointers to the data."]}),"\n",(0,t.jsx)(n.p,{children:"By way of example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"/* Class variables */\n// \nSST::Link* link;\nSST::Output* output;\nSST::TimeConverter* tc;\nint count;\nstd::string name;\nstd::vector<uint32_t> nums;\nstd::string pointedToObj;\nstd::string* pointer = &pointedToObj;\n\n/* Serialization function */\nvoid serialize_order(SST::Core::Serialization::Serializer& ser) override\n{\n    BaseClass::serialize_order(ser); // Assuming this class has a base class called 'BaseClass'. ALWAYS call the base class's serialize_order function prior to adding data from this class.\n    SST_SER(link)\n    SST_SER(output)\n    SST_SER(tc)\n    SST_SER(count)\n    SST_SER(name)\n    SST_SER(nums)\n    SST_SER_AS_PTR(pointedToObj) // Track a pointer to this object\n    SST_SER(pointer)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Many data types are supported natively in SST's serialization libraries. These include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"POD types"}),"\n",(0,t.jsx)(n.li,{children:"Pointers to POD types"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"std::vector"}),", ",(0,t.jsx)(n.code,{children:"std::set"}),", ",(0,t.jsx)(n.code,{children:"std::map"}),", ",(0,t.jsx)(n.code,{children:"std::multiset"}),", ",(0,t.jsx)(n.code,{children:"std::priority_queue"})]}),"\n",(0,t.jsxs)(n.li,{children:["SST types: ",(0,t.jsx)(n.code,{children:"Link"}),", ",(0,t.jsx)(n.code,{children:"TimeConverter"}),", ",(0,t.jsx)(n.code,{children:"Output"}),", ",(0,t.jsx)(n.code,{children:"RNG:Random"}),", ",(0,t.jsx)(n.code,{children:"RNG:RandomDistribution"}),", ",(0,t.jsx)(n.code,{children:"SharedArray"}),", ",(0,t.jsx)(n.code,{children:"SharedMap"}),", ",(0,t.jsx)(n.code,{children:"SharedSet"}),", ",(0,t.jsx)(n.code,{children:"UnitAlgebra"})]}),"\n",(0,t.jsxs)(n.li,{children:["Handlers: ",(0,t.jsx)(n.code,{children:"Clock::Handler2"}),", ",(0,t.jsx)(n.code,{children:"Event::Handler2"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Note that non-polymorphic classes/structs are special cases in the serialization library. Because there is no way to reference the class with a different type, there is no need to inherit from ",(0,t.jsx)(n.code,{children:"Serializable"})," or call the ",(0,t.jsx)(n.code,{children:"ImplementSerializable"})," macro (step 4 below). You may simply add a ",(0,t.jsx)(n.code,{children:"serialize_order()"})," function to the class as listed above and the class will be compatible with the serializer."]}),"\n",(0,t.jsx)(n.h3,{id:"step-4-add-the-appropriate-serialization-macro",children:"Step 4: Add the appropriate serialization macro"}),"\n",(0,t.jsxs)(n.p,{children:["Classes that inherit from ",(0,t.jsx)(n.code,{children:"SST::Core::Serialization::serializable"})," must call the ",(0,t.jsx)(n.code,{children:"ImplementSerializable"})," macro with their class name. Note that the macro should be called from a public section of the class definition."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"MyClass : public SST::Component\n{\npublic:\n    // Class functions\n    \n    ImplementSerializable(MyClass)\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Pure virtual classes must use ",(0,t.jsx)(n.code,{children:"ImplementVirtualSerializable"})," instead of ",(0,t.jsx)(n.code,{children:"ImplementSerializable"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"put-it-together-an-example",children:"Put it together: An example"}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of what this looks like. Note we've removed all but the relevant-to-checkpointing pieces of the class (ELI macros, most class functions, etc.)."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="example.h"',children:"#ifndef SST_EXAMPLE_CHECKPOINT_HEADER\n#define SST_EXAMPLE_CHECKPOINT_HEADER\n\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n#include <sst/core/rng/marsaglia.h>\n\nnamespace SST {\nnamespace ExampleSSTLibrary {\n\nclass example : public SST::Component {\npublic:\n    // ELI macros would be here\n    \n    // Public class members would be here\n\n    //highlight-start\n    // Add default constructor, serialize_order, and serializable macro\n    example();\n    void serialize_order(SST::Core::Serialization::serializer& ser) override;\n    ImplementSerializable(SST::ExampleSSTLibrary::example)\n    //highlight-end\nprivate:\n    // Private member functions would be here\n\n    // Private data members - to be serialized in serialize_order\n    int64_t param0;\n    uint32_t param1;\n    std::string param2;\n    Statistic<uint64_t> stat;\n    SST::Output* out;\n    std::vector<std::string> stringVec;\n    SST::Link* link;\n    RNG::Random* rng;\n};\n\n} } // End namespaces\n#endif\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",metastring:'title="example.cc"',children:"// Rest of class defined here\n\n// highlight-start\nexample::example() : Component() {}\n\nvoid example::serialize_order(SST::Core::Serialization::serializer& ser) {\n    // MUST call parent's serialize_order FIRST\n    Component::serialize_order(ser);\n\n    // Now, serialize everything we need to save\n    SST_SER(param0)\n    SST_SER(param1)\n    SST_SER(param2)\n    SST_SER(stat)\n    SST_SER(out)\n    SST_SER(stringVec)\n    SST_SER(link)\n    SST_SER(rng)\n}\n//highlight-end\n\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-notes-on-serialization",children:"Advanced notes on serialization"}),"\n",(0,t.jsx)(n.p,{children:"While many types are serializable already within SST's serialization engine, complex types may require additional work."}),"\n",(0,t.jsxs)(n.p,{children:["The serializer has three stages: (1) SIZER, (2) PACK, and (3) UNPACK. The first two comprise serialization (checkpoint) and the third is deserialization (restart). The serializer calls ",(0,t.jsx)(n.code,{children:"serialize_order"})," once during each of these three stages. Thus, if the default serialization does not work for a particular type, a custom serialization can be implemented by querying the serializer's mode in the ",(0,t.jsx)(n.code,{children:"serialize_order"})," function and taking the appropriate action to serialize the type. During ",(0,t.jsx)(n.code,{children:"SIZER"}),", the ",(0,t.jsx)(n.code,{children:"serialize_order"})," should add the size of the data to be serialized using the ",(0,t.jsx)(n.code,{children:"&"})," or ",(0,t.jsx)(n.code,{children:"|"})," operator. During ",(0,t.jsx)(n.code,{children:"PACK"}),", ",(0,t.jsx)(n.code,{children:"serialize_order"})," should add the data to be added to the serialization stream using the ",(0,t.jsx)(n.code,{children:"&"})," or ",(0,t.jsx)(n.code,{children:"|"})," operator. Finally, during ",(0,t.jsx)(n.code,{children:"UNPACK"}),", ",(0,t.jsx)(n.code,{children:"serialize_order"})," should read the serialized data from the stream, again using the ",(0,t.jsx)(n.code,{children:"&"})," or ",(0,t.jsx)(n.code,{children:"|"})," operator. The same operator should be used in all three stages."]}),"\n",(0,t.jsxs)(n.p,{children:["As an example, the code snippet below shows how ",(0,t.jsx)(n.code,{children:"SST::UnitAlgebra"}),' is serialized. UnitAlgebra has two components, a "unit" struct that contains a numerator (string) and denominator (string) and a "value" object that is a custom type called ',(0,t.jsx)(n.code,{children:"decimal_fixedpoint"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['The "unit" struct consists of strings so UnitAlgebra serializes the struct\'s members using the ',(0,t.jsx)(n.code,{children:"&"})," operator in all three serializer stages (",(0,t.jsx)(n.code,{children:"SIZER"}),", ",(0,t.jsx)(n.code,{children:"PACK"}),", and ",(0,t.jsx)(n.code,{children:"UNPACK"}),"). To serialize ",(0,t.jsx)(n.code,{children:"decimal_fixedpoint"}),", SST converts it to a string, stores the string, and then, on deserialization, re-initializes a new ",(0,t.jsx)(n.code,{children:"decimal_fixedpoint"})," type using the stored string."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that the ",(0,t.jsx)(n.code,{children:"SST_SER"})," macro is only useful for class members - ",(0,t.jsx)(n.code,{children:"unit.numerator"})," and ",(0,t.jsx)(n.code,{children:"unit.denominator"})," in the example below. For temporaries, use the raw (",(0,t.jsx)(n.code,{children:"&"})," or ",(0,t.jsx)(n.code,{children:"|"}),") serialization operators."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-cpp",children:"    void serialize_order(SST::Core::Serialization::serializer& ser) override\n    {\n        // Do the unit - these are both strings, no special handling required\n        SST_SER(unit.numerator);\n        SST_SER(unit.denominator);\n\n        // For value, first convert to a string\n        // Then, reinitialize from the string\n        switch ( ser.mode() ) {\n        case SST::Core::Serialization::serializer::SIZER:\n        case SST::Core::Serialization::serializer::PACK:\n        {\n            std::string s = value.toString(0);\n            // The next line will get the size of the string during SIZER\n            // and will pack the string into the serialization stream during PACK\n            ser&        s; // Could equivalently use SST_SER but not needed since 's' is not a class member\n            break;\n        }\n        case SST::Core::Serialization::serializer::UNPACK:\n        {   \n            // Extract the serialized string from the stream\n            std::string s;\n            ser&        s;\n            // Reinitialize 'value' using the string\n            value = sst_big_num(s);\n            break;\n        }\n        }\n    }\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>o});var t=i(96540);const a={},s=t.createContext(a);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);
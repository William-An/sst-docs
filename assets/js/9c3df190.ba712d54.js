"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[185],{8998:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>r});var s=t(85893),i=t(11151);const o={title:"SST::Link"},a=void 0,c={id:"core/link/class",title:"SST::Link",description:"SST Links connect (sub)components and enable components to send events to each other. Links can be configured to use a callback handler when an event arrives or can be configured without a handler so that they must be polled.",source:"@site/../docs/core/link/class.md",sourceDirName:"core/link",slug:"/core/link/class",permalink:"/sst-docs/docs/core/link/class",draft:!1,unlisted:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/link/class.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1695940750,formattedLastUpdatedAt:"Sep 28, 2023",frontMatter:{title:"SST::Link"},sidebar:"core",previous:{title:"TestEvent",permalink:"/sst-docs/docs/core/iface/TestEvent/class"},next:{title:"send",permalink:"/sst-docs/docs/core/link/send"}},l={},r=[{value:"Simulation LifeCycle and Links",id:"simulation-lifecycle-and-links",level:2},{value:"Link latency",id:"link-latency",level:2},{value:"Creation",id:"creation",level:2},{value:"Header",id:"header",level:2}];function d(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"SST Links connect (sub)components and enable components to send events to each other. Links can be configured to use a callback handler when an event arrives or can be configured without a handler so that they must be polled."}),"\n",(0,s.jsx)(n.h2,{id:"simulation-lifecycle-and-links",children:"Simulation LifeCycle and Links"}),"\n",(0,s.jsx)(n.p,{children:"During SST's init() and complete() phases, the sendUntimedData() and recvUntimedData() functions can be used to send events between (sub)components. The regular send() and recv() functions are unavailable, and links must be polled during these phases. Once SST enters setup(), (sub)components can send events on Links using the regular functions and the events will be handled when simulation begins."}),"\n",(0,s.jsx)(n.h2,{id:"link-latency",children:"Link latency"}),"\n",(0,s.jsxs)(n.p,{children:["Links are declared in the SST configuration input file with a latency. This is the minimum latency that an event will experience on the link. Within (sub)components, the ",(0,s.jsx)(n.code,{children:"addSendLatency"})," and ",(0,s.jsx)(n.code,{children:"addRecvLatency"})," as well as some of the ",(0,s.jsx)(n.code,{children:"send"})," functions can be used to add additional latency to the link. For example, if a link is configured in the input file with 200ns of latency, an event will arrive 200ns after it was sent. If however the sender sends the event with a 20ns latency, the event would arrive 200 + 20 = 220ns later."]}),"\n",(0,s.jsx)(n.p,{children:"Links cannot have a zero latency. The exception to this is a SelfLink. A SelfLink is identical to a Link except that both ends of the link connect to the same component or subcomponent. SelfLinks are often used by components to time internal activities."}),"\n",(0,s.jsx)(n.h2,{id:"creation",children:"Creation"}),"\n",(0,s.jsxs)(n.p,{children:["Links are not created directly by (sub)components. Instead, (sub)components use (Sub)Component API functions such as ",(0,s.jsx)(n.code,{children:"configureLink()"})," to acquire a handle to a link. Links must be declared in the SST input configuration. SelfLinks do not need to be declared in the input configuration, the component can configure these in their constructors."]}),"\n",(0,s.jsx)(n.h2,{id:"header",children:"Header"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"#include <sst/core/link.h>\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var s=t(67294);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);
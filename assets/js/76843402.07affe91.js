"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1888],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>g});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var i=n.createContext({}),p=function(e){var t=n.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):d(d({},t),e)),r},m=function(e){var t=p(e.components);return n.createElement(i.Provider,{value:t},e.children)},l="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,i=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),l=p(r),u=a,g=l["".concat(i,".").concat(u)]||l[u]||c[u]||s;return r?n.createElement(g,d(d({ref:t},m),{},{components:r})):n.createElement(g,d({ref:t},m))}));function g(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,d=new Array(s);d[0]=u;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o[l]="string"==typeof e?e:a,d[1]=o;for(var p=2;p<s;p++)d[p]=r[p];return n.createElement.apply(null,d)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},81422:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>i,contentTitle:()=>d,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const s={title:"setMemoryMappedAddressRegion"},d=void 0,o={unversionedId:"core/iface/StandardMem/setMemoryMappedAddressRegion",id:"core/iface/StandardMem/setMemoryMappedAddressRegion",title:"setMemoryMappedAddressRegion",description:"Set which addresses in the global address space will map to this endpoint. Only contiguous address ranges are supported. By default, the endpoint is not addressable. The mapped region will be [start, start+size).",source:"@site/../docs/core/iface/StandardMem/setMemoryMappedAddressRegion.md",sourceDirName:"core/iface/StandardMem",slug:"/core/iface/StandardMem/setMemoryMappedAddressRegion",permalink:"/sst-docs/docs/core/iface/StandardMem/setMemoryMappedAddressRegion",draft:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/StandardMem/setMemoryMappedAddressRegion.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1695940750,formattedLastUpdatedAt:"Sep 28, 2023",frontMatter:{title:"setMemoryMappedAddressRegion"},sidebar:"core",previous:{title:"sendUntimedData",permalink:"/sst-docs/docs/core/iface/StandardMem/sendUntimedData"},next:{title:"StandardMem::Request",permalink:"/sst-docs/docs/core/iface/StandardMem/req/class"}},i={},p=[{value:"Requirements",id:"requirements",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1: Implementing setMemoryMappedAddressRegion in a StandardMem interface",id:"example-1-implementing-setmemorymappedaddressregion-in-a-standardmem-interface",level:3},{value:"Example 2: Using setMemoryMappedAddressRegion from an endpoint",id:"example-2-using-setmemorymappedaddressregion-from-an-endpoint",level:3},{value:"Header",id:"header",level:2}],m={toc:p},l="wrapper";function c(e){let{components:t,...r}=e;return(0,a.kt)(l,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual void setMemoryMappedAddressRegion(Addr start, Addr size);\n")),(0,a.kt)("p",null,"Set which addresses in the global address space will map to this endpoint. Only contiguous address ranges are supported. By default, the endpoint is not addressable. The mapped region will be ",(0,a.kt)("inlineCode",{parentName:"p"},"[start, start+size)"),"."),(0,a.kt)("h2",{id:"requirements"},"Requirements"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Memory interface")," ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n","Support setting memory mapped addresses if supported by the memory system. The function must be implemented, but a particular implementation can raise an error if this is not supported."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Endpoint")," ","\xa0",(0,a.kt)("br",{parentName:"p"}),"\n","Call this function to set the addressable region if the endpoint needs to be mapped into the memory space."),(0,a.kt)("h2",{id:"parameters"},"Parameters"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"start")," (Addr) starting address mapped to this endpoint"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"size")," (Addr) number of bytes mapped to this endpoint"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"returns")," none")),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"example-1-implementing-setmemorymappedaddressregion-in-a-standardmem-interface"},"Example 1: Implementing setMemoryMappedAddressRegion in a StandardMem interface"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/memHierarchy/standardInterface.cc"',title:'"Excerpt',from:!0,'sst-elements/src/sst/elements/memHierarchy/standardInterface.cc"':!0},"void StandardInterface::setMemoryMappedAddressRegion(Addr start, Addr size) {\n    region.start = start;\n    region.end = start + size - 1;\n    region.interleaveStep = 0;\n    region.interleaveSize = 0;\n    epType = Endpoint::MMIO;\n    link_->setRegion(region);\n}\n")),(0,a.kt)("h3",{id:"example-2-using-setmemorymappedaddressregion-from-an-endpoint"},"Example 2: Using setMemoryMappedAddressRegion from an endpoint"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"mem_iface->setMemoryMappedAddressRegion(256, 64);\n")),(0,a.kt)("h2",{id:"header"},"Header"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/interfaces/stdMem.h>\n")))}c.isMDXComponent=!0}}]);
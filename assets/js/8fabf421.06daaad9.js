"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6337],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>v});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,v=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return t?i.createElement(v,a(a({ref:n},p),{},{components:t})):i.createElement(v,a({ref:n},p))}));function v(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=t[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9530:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>v,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var i=t(7462),r=t(3366),o=(t(7294),t(3905)),a=["components"],s={title:"init"},l=void 0,c={unversionedId:"core/component/lifecycle/init",id:"core/component/lifecycle/init",title:"init",description:"\x3c!---",source:"@site/../docs/core/component/lifecycle/init.md",sourceDirName:"core/component/lifecycle",slug:"/core/component/lifecycle/init",permalink:"/sst-website/docs/core/component/lifecycle/init",draft:!1,editUrl:"https://github.com/sstsimulator/docs/edit/master/docs/../docs/core/component/lifecycle/init.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1675712938,formattedLastUpdatedAt:"Feb 6, 2023",frontMatter:{title:"init"},sidebar:"Core API",previous:{title:"destructor",permalink:"/sst-website/docs/core/component/componentext/destructor"},next:{title:"setup",permalink:"/sst-website/docs/core/component/lifecycle/setup"}},p={},d=[{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Header",id:"header",level:2},{value:"Header",id:"header-1",level:2}],u={toc:d},m="wrapper";function v(e){var n=e.components,t=(0,r.Z)(e,a);return(0,o.kt)(m,(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual void init(unsigned phase);\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Availability:")," Component, SubComponent, ComponentExtension"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"init()")," function is called by SST after all components are constructed but before simulation begins. It is an opportunity to set up state and prepare for simulation. Components may send events during init but must use the special untimed send and receive functions. Event handlers are not yet active so links must be polled. Init occurs in rounds or phases, with events sent in a prior round delivered in the subsequent round. All components participate in all rounds. SST calls ",(0,o.kt)("inlineCode",{parentName:"p"},"init()")," in a loop until there are no events to deliver in the next round."),(0,o.kt)("admonition",{title:"Important",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"This function is called by SSTCore on Components only. Components, SubComponents, and ComponentExtensions must in turn manually call ",(0,o.kt)("inlineCode",{parentName:"p"},"init()")," on their SubComponents and ComponentExtensions. This allows developers to control both whether those objects participate in the Init phase, and the order in which they participate. ")),(0,o.kt)("h2",{id:"parameters"},"Parameters"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"phase")," (unsigned) The phase or round number (i.e., number of times ",(0,o.kt)("inlineCode",{parentName:"li"},"init()")," has been called on all components)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"returns")," none")),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("h3",{id:"example-1"},"Example 1"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'/********* basicSimLifeCycle.h **********/\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n\nclass basicSimLifeCycle : public SST::Component {\n  public:\n    \n    /** ELI removed for brevity, would be here **/\n\n    basicSimLifeCycle(SST::ComponentId_t id, SST::Params& params);\n    ~basicSimLifeCycle();\n\n    virtual void init(unsigned phase) override;\n\n    /** Other public functions here */\n\n  private:\n    // Parameters\n    unsigned eventsToSend;\n    bool verbose;\n\n    // Component state\n    unsigned eventsReceived;                // Number of events we\'ve received\n    unsigned eventsForwarded;               // Number of events we\'ve forwarded\n    unsigned eventsSent;                    // Number of events we\'ve sent (initiated)\n    std::set<std::string> neighbors;        // Set of all neighbors on the ring\n    std::set<std::string>::iterator iter;   // Next component to send to in the eventRequests map \n\n    // Additional state reported during finish\n    std::string leftMsg, rightMsg;\n\n    // SST Output object, for printing, error messages, etc.\n    SST::Output* out;\n\n    // Links\n    SST::Link* leftLink;\n    SST::Link* rightLink;\n}\n\n/********* basicSimLifeCycle.cc *********/\n#include "sst_config.h"\n#include "basicSimLifeCycle.h"\n\nvoid basicSimLifeCycle::init(unsigned int phase) {\n\n    // Only send our info on phase 0\n    if (phase == 0) {\n        basicLifeCycleEvent* event = new basicLifeCycleEvent(getName(), eventsToSend);\n        leftLink->sendUntimedData(event);\n    }\n\n    // Check if an event is received. recvUntimedData returns nullptr if no event is available\n    while (SST::Event* ev = rightLink->recvUntimedData()) {\n\n        basicLifeCycleEvent* event = dynamic_cast<basicLifeCycleEvent*>(ev);\n\n        if (event) {\n            if (event->getStr() == getName()) { // Event made it around the ring and back to this component\n                delete event;\n            } else { // Event is from another component\n                neighbors.insert(event->getStr());\n                eventsToSend += event->getNum();\n                leftLink->sendUntimedData(event);\n            }\n\n        } else {\n            out->fatal(CALL_INFO, -1, "Error in %s: Received an event during init() but it is not the expected type\\n", getName().c_str());\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"header"},"Header"),(0,o.kt)("h2",{id:"header-1"},"Header"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentExtension.h>\n")))}v.isMDXComponent=!0}}]);
"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1047],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=r.createContext({}),s=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(i.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),u=s(n),d=o,k=u["".concat(i,".").concat(d)]||u[d]||m[d]||l;return n?r.createElement(k,c(c({ref:t},p),{},{components:n})):r.createElement(k,c({ref:t},p))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,c=new Array(l);c[0]=d;var a={};for(var i in t)hasOwnProperty.call(t,i)&&(a[i]=t[i]);a.originalType=e,a[u]="string"==typeof e?e:o,c[1]=a;for(var s=2;s<l;s++)c[s]=n[s];return r.createElement.apply(null,c)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},42854:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>a,toc:()=>s});var r=n(87462),o=(n(67294),n(3905));const l={title:"reregisterClock"},c=void 0,a={unversionedId:"core/component/time/reregisterClock",id:"core/component/time/reregisterClock",title:"reregisterClock",description:"Availability: Component, SubComponent, ComponentExtension",source:"@site/../docs/core/component/time/reregisterClock.md",sourceDirName:"core/component/time",slug:"/core/component/time/reregisterClock",permalink:"/sst-docs/docs/core/component/time/reregisterClock",draft:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/component/time/reregisterClock.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1684522150,formattedLastUpdatedAt:"May 19, 2023",frontMatter:{title:"reregisterClock"},sidebar:"core",previous:{title:"unregisterClock",permalink:"/sst-docs/docs/core/component/time/unregisterClock"},next:{title:"getNextClockCycle",permalink:"/sst-docs/docs/core/component/time/getNextClockCycle"}},i={},s=[{value:"Parameters",id:"parameters",level:2},{value:"Example",id:"example",level:2},{value:"Header",id:"header",level:2}],p={toc:s},u="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"Cycle_t reregisterClock(TimeConverter* freq, Clock::HandlerBase* handler);\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Availability:")," Component, SubComponent, ComponentExtension"),(0,o.kt)("p",null,"Re-register a clock at the specified frequency. On each clock cycle, the associated handler will be called. Calling this function for a clock frequency that was not previously registered will cause an error. The function will return the cycle count (in terms of the clock frequency) at which the clock will next be called."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Note:")," If called after the simulation run loop (e.g., in ",(0,o.kt)("inlineCode",{parentName:"p"},"finish()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"complete()"),")), the cycle time returned by this function will be one cycle past the end time of the simulation. Because there can be a small lag bectween simulation end and detection of simulation end, during which clocks can run a few extra cycles, the return value of this function just prior to simulation end may be greater than the value returned after simulation end."),(0,o.kt)("h2",{id:"parameters"},"Parameters"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"freq")," (string, UnitAlgebra, TimeConverter*) Frequency of the clock"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"handler")," (Clock::HandlerBase*) Clock handler function to invoke each cycle"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"returns")," (Cycle_t) Cycle count, in terms of clock frequency, that the re-registered clock handler will next be called at ")),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'/* \n * Example component. Events toggle the clock registration.\n */\nclass Sender : public SST::Component {\npublic:\n    /** ELI removed for brevity */\n\n    Sender(ComponentId_t id, Params& params) : Component(id)\n    {\n        clockOn = true;\n        clockHandler = new Clock::Handler<Sender>(this, &Sender::handleClock);\n        clockTimeConverter = registerClock("1GHz", clockHandler);\n\n        /** Other configuration here */\n    }\n\n    /** Event handler, called when an event arrives */\n    void handleEvent(SST::Event *ev) {\n        if (clockOn) {\n            clockOn = false;\n            unregisterClock(clockTimeConverter, clockHandler);\n        } else {\n            clockOn = true;\n            //highlight-next-line\n            reregisterClock(clockTimeConverter, clockHandler);\n        }\n        delete ev;\n    }\n\n    /** Clock handler */\n    bool handleClock(Cycle_t cycle) {\n        output.output("Clock called at cycle %" PRIu64 "\\n", cycle);\n        return false;\n    }\nprivate:\n    bool clockOn;\n    TimeConverter* clockTimeConverter;\n    Clock::Handler<Sender>* clockHandler;\n    /* Other class members here */\n};\n')),(0,o.kt)("h2",{id:"header"},"Header"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/component.h> // or\n#include <sst/core/subcomponent.h> // or\n#include <sst/core/componentExtension.h>\n")))}m.isMDXComponent=!0}}]);
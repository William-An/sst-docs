"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1672],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var o=r.createContext({}),s=function(e){var t=r.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=s(e.components);return r.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),c=s(a),d=n,f=c["".concat(o,".").concat(d)]||c[d]||m[d]||l;return a?r.createElement(f,i(i({ref:t},u),{},{components:a})):r.createElement(f,i({ref:t},u))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=c;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:n,i[1]=p;for(var s=2;s<l;s++)i[s]=a[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4322:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>d,frontMatter:()=>p,metadata:()=>s,toc:()=>m});var r=a(7462),n=a(3366),l=(a(7294),a(3905)),i=["components"],p={id:"init",title:"init()"},o=void 0,s={unversionedId:"cpp/output/init",id:"cpp/output/init",title:"init()",description:"Fully Qualified Name",source:"@site/../docs/cpp/output/init.md",sourceDirName:"cpp/output",slug:"/cpp/output/init",permalink:"/sst-website/docs/cpp/output/init",draft:!1,editUrl:"https://github.com/sstsimulator/sst-website/edit/master/docs/../docs/cpp/output/init.md",tags:[],version:"current",lastUpdatedBy:"Ryan Ledbetter",lastUpdatedAt:1539909317,formattedLastUpdatedAt:"Oct 19, 2018",frontMatter:{id:"init",title:"init()"},sidebar:"C++",previous:{title:"fatal()",permalink:"/sst-website/docs/cpp/output/fatal"},next:{title:"output()",permalink:"/sst-website/docs/cpp/output/"}},u={},m=[{value:"Fully Qualified Name",id:"fully-qualified-name",level:2},{value:"Remarks",id:"remarks",level:3},{value:"Requirements",id:"requirements",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Return Value",id:"return-value",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"See Also",id:"see-also",level:2}],c={toc:m};function d(e){var t=e.components,a=(0,n.Z)(e,i);return(0,l.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"fully-qualified-name"},"Fully Qualified Name"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"SST::Output::init()\n")),(0,l.kt)("h3",{id:"remarks"},"Remarks"),(0,l.kt)("p",null,"Sets a prefix that is prepended to most strings emitted, parameters for when to emit verbose/debug strings, and where strings should be emitted (STDOUT, STDERR, or a FILE)."),(0,l.kt)("h2",{id:"requirements"},"Requirements"),(0,l.kt)("p",null,"Main definition"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/output.h>\n")),(0,l.kt)("p",null,"Also included in the following"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/simulation.h>\n#include <sst/core/component.h>\n")),(0,l.kt)("h2",{id:"syntax"},"Syntax"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'void SST::Output::init(const std::string& prefix, uint32_t verbose_level, uint32_t verbose_mask, output_location_t location, std::string localoutputfilename = "")\n')),(0,l.kt)("h2",{id:"parameters"},"Parameters"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"prefix")," - A string to be prepended to all messages emitted by calls to ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/debug"},"debug()"),", ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/verbose"},"verbose()"),", ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/fatal"},"fatal()")," and possibly ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/"},"output()"),". No space will be inserted between the prepended prefix string and the message. The prefix can contain the following escape codes:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@f")," - Name of the file in which the output call was made."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@l")," - Line number in the file in which output call was made."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@p")," - Name of the function from which the output call was made."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@r")," - MPI rank of the calling process. Will be empty if MPI_COMM_WORLD size is 1."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@R")," - MPI rank of the calling process. Will be 0 if MPI_COMM_WORLD size is 1."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@i")," - Thread Id of the calling process. Will be empty if number of threads is 1."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@I")," - Thread Id of the calling process. Will be 0 if number of threads is 1."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@x")," - Rank information of the calling process. Will be empty if number of MPI ranks and number of threads are both 1. Same as ",(0,l.kt)("strong",{parentName:"li"},"[@r:@i]"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@X")," - Rank information of the calling process. Will be ","[0.0]"," if number of MPI ranks and number of threads are both 1. Same as ",(0,l.kt)("strong",{parentName:"li"},"[@R:@I]"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"@t")," - Simulation time. Will be the raw simulation cycle time retrieved from SST Core.")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"verbose_level")," - \tDebugging output level. Calls to ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/debug"},"debug()"),", and ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/verbose"},"verbose()")," are outputted only if their output_level parameter is less than or equal to the verbose_level currently set for this object."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"verbose_mask")," - Bitmask of allowed message types for ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/debug"},"debug()"),", and ",(0,l.kt)("a",{parentName:"p",href:"/sst-website/docs/cpp/output/verbose"},"verbose()"),". The Output object will only output the message if the set bits of the output_bits parameter are set in the verbose_mask of the object. It uses this logic: if (~verbose_mask & output_bits == 0) then output is enabled."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"location")," - Output location. Output will be directed to STDOUT, STDERR, FILE, or NONE. If FILE output is selected, the output will be directed to the file defined by the \u2013debug runtime parameter, or to the file 'sst_output' if the \u2013debug parameter is not defined. If the size of MPI_COMM_WORLD is > 1, then the rank process will be appended to the file name."),(0,l.kt)("p",null,"One of:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"SST::Output::STDOUT"),(0,l.kt)("li",{parentName:"ul"},"SST::Output::STDERR"),(0,l.kt)("li",{parentName:"ul"},"SST::Output::FILE"),(0,l.kt)("li",{parentName:"ul"},"SST::Output::NONE")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"localoutputfilename")," - Send the output of this class to the file identified in localoutputfilename instead of the of the normal output file set by the run time parameter \u2013debug-file. ",(0,l.kt)("strong",{parentName:"p"},"location")," parameter must be set to FILE. This parameter is intended for special case debug purposes only."),(0,l.kt)("h2",{id:"return-value"},"Return Value"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"None")),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("h3",{id:"example-1"},"Example 1"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},'SST::Output output;\noutput.init("bay-" + getName() + "-> ", 1, 0, SST::Output::STDOUT);\n')),(0,l.kt)("h2",{id:"see-also"},"See Also"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/sst-website/docs/cpp/output/"},"output()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/sst-website/docs/cpp/output/debug"},"debug()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/sst-website/docs/cpp/output/verbose"},"verbose()")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"/sst-website/docs/cpp/output/fatal"},"fatal()"))))}d.isMDXComponent=!0}}]);
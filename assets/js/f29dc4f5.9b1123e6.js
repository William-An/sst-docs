"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7137],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>v});var r=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),p=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},s=function(e){var n=p(e.components);return r.createElement(c.Provider,{value:n},e.children)},l="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),l=p(t),u=o,v=l["".concat(c,".").concat(u)]||l[u]||d[u]||i;return t?r.createElement(v,a(a({ref:n},s),{},{components:t})):r.createElement(v,a({ref:n},s))}));function v(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=u;var m={};for(var c in n)hasOwnProperty.call(n,c)&&(m[c]=n[c]);m.originalType=e,m[l]="string"==typeof e?e:o,a[1]=m;for(var p=2;p<i;p++)a[p]=t[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},9767:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>v,frontMatter:()=>m,metadata:()=>p,toc:()=>l});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),a=["components"],m={title:"primaryComponentOKToEndSim"},c=void 0,p={unversionedId:"core/component/component/primaryComponentOKToEndSim",id:"core/component/component/primaryComponentOKToEndSim",title:"primaryComponentOKToEndSim",description:"Availability: Component",source:"@site/../docs/core/component/component/primaryComponentOKToEndSim.md",sourceDirName:"core/component/component",slug:"/core/component/component/primaryComponentOKToEndSim",permalink:"/docs/docs/core/component/component/primaryComponentOKToEndSim",draft:!1,editUrl:"https://github.com/sstsimulator/docs/edit/master/docs/../docs/core/component/component/primaryComponentOKToEndSim.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1675712938,formattedLastUpdatedAt:"Feb 6, 2023",frontMatter:{title:"primaryComponentOKToEndSim"},sidebar:"Core API",previous:{title:"primaryComponentDoNotEndSim",permalink:"/docs/docs/core/component/component/primaryComponentDoNotEndSim"},next:{title:"SST::SubComponent",permalink:"/docs/docs/core/component/subcomponent/class"}},s={},l=[{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Header",id:"header",level:2}],d={toc:l},u="wrapper";function v(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)(u,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void primaryComponentOKToEndSim();\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Availability"),": Component"),(0,i.kt)("p",null,"A primary component that has previous registered using ",(0,i.kt)("a",{parentName:"p",href:"registerAsPrimaryComponent"},"registerAsPrimaryComponent()")," calls this function to let the simulation know that it is currently OK to end simulation. Simulation will not end until all primary components have called this function."),(0,i.kt)("p",null,"To change status and prevent simulation end, use ",(0,i.kt)("a",{parentName:"p",href:"primaryComponentDoNotEndSim"},"primaryComponentDoNoEndSim()"),"."),(0,i.kt)("h2",{id:"parameters"},"Parameters"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"returns")," None")),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("h3",{id:"example-1"},"Example 1"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"/********* basicSimLifeCycle.h **********/\n#include <sst/core/component.h>\n#include <sst/core/link.h>\n\nclass basicSimLifeCycle : public SST::Component {\n  public:\n    \n    /** ELI removed for brevity, would be here **/\n\n    basicSimLifeCycle(SST::ComponentId_t id, SST::Params& params);\n    ~basicSimLifeCycle();\n\n    void handleEvent(SST::Event* ev);\n    \n    /** Other public functions here */\n\n  private:\n    // Parameters\n    unsigned eventsToSend;                  // Number of events we will send and receive\n    bool verbose;\n\n    // Component state\n    unsigned eventsReceived;                // Number of events we've received\n    unsigned eventsForwarded;               // Number of events we've forwarded\n    unsigned eventsSent;                    // Number of events we've sent (initiated)\n\n    /** Other private class members here */\n}\n\n/********* basicSimLifeCycle.cc *********/\n#include \"sst_config.h\"\n#include \"basicSimLifeCycle.h\"\n\nbasicSimLifeCycle::basicSimLifeCycle( SST::ComponentId_t id, SST::Params& params ) : SST::Component(id) \n{\n    /** Rest of constructor here */\n\n    // Register as primary and prevent simulation end until we've received all the events we need\n    registerAsPrimaryComponent();\n    primaryComponentDoNotEndSim();\n}\n\n/* Event handler for use during SST's run loop */\nvoid basicSimLifeCycle::handleEvent(SST::Event* ev) {\n    basicLifeCycleEvent* event = dynamic_cast<basicLifeCycleEvent*>(ev);\n\n    if (event && event->getStr() == getName()) {\n        eventsReceived++;\n        delete event;\n\n        // We send the same number of events that we receive\n        // If we've received all the events we expect, it's OK to end simulation\n        if (eventsReceived == eventsToSend)\n            primaryComponentOKToEndSim();\n    }\n\n    /** Rest of handler here */\n}\n")),(0,i.kt)("h2",{id:"header"},"Header"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/component.h>\n")))}v.isMDXComponent=!0}}]);
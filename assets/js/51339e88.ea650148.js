"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1631],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,f=d["".concat(l,".").concat(u)]||d[u]||m[u]||a;return n?i.createElement(f,o(o({ref:t},c),{},{components:n})):i.createElement(f,o({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},18020:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var i=n(87462),r=(n(67294),n(3905));const a={title:"init"},o=void 0,s={unversionedId:"core/iface/SimpleNetwork/init",id:"core/iface/SimpleNetwork/init",title:"init",description:"See init() for a description of SST's init phase and the use of this function. The (Sub)Component that loaded a SimpleNetwork interface should call this function during its own init() function. A SimpleNetwork interface should faciliate sending untimed requests during the init() phase, however, it may use the isNetworkInitialized() function to block an endpoint from sending requests until it is ready to accept them.",source:"@site/../docs/core/iface/SimpleNetwork/init.md",sourceDirName:"core/iface/SimpleNetwork",slug:"/core/iface/SimpleNetwork/init",permalink:"/sst-docs/docs/core/iface/SimpleNetwork/init",draft:!1,editUrl:"https://github.com/sstsimulator/sst-docs/edit/master/docs/../docs/core/iface/SimpleNetwork/init.md",tags:[],version:"current",lastUpdatedBy:"grvosku",lastUpdatedAt:1684522150,formattedLastUpdatedAt:"May 19, 2023",frontMatter:{title:"init"},sidebar:"core",previous:{title:"destructor",permalink:"/sst-docs/docs/core/iface/SimpleNetwork/destructor"},next:{title:"setup",permalink:"/sst-docs/docs/core/iface/SimpleNetwork/setup"}},l={},p=[{value:"Requirements",id:"requirements",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Examples",id:"examples",level:2},{value:"Example 1: Initializing a newtork, from a SimpleNetwork interface&#39;s point of view",id:"example-1-initializing-a-newtork-from-a-simplenetwork-interfaces-point-of-view",level:3},{value:"Example 2: Initializing a network, from the endpoint&#39;s point of view",id:"example-2-initializing-a-network-from-the-endpoints-point-of-view",level:3},{value:"Header",id:"header",level:2}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"virtual void init(unsigned int phase);\n")),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"../../component/lifecycle/init"},(0,r.kt)("inlineCode",{parentName:"a"},"init()"))," for a description of SST's init phase and the use of this function. The (Sub)Component that loaded a SimpleNetwork interface should call this function during its own ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," function. A SimpleNetwork interface should faciliate sending untimed requests during the init() phase, however, it may use the ",(0,r.kt)("a",{parentName:"p",href:"isNetworkInitialized"},(0,r.kt)("inlineCode",{parentName:"a"},"isNetworkInitialized()"))," function to block an endpoint from sending requests until it is ready to accept them."),(0,r.kt)("h2",{id:"requirements"},"Requirements"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Network interface")," ","\xa0",(0,r.kt)("br",{parentName:"p"}),"\n","Faciliate sending untimed requests sent by endpoints through the network. The network does not need to facilitate sending requests until the interface's ",(0,r.kt)("a",{parentName:"p",href:"isNetworkInitialized"},(0,r.kt)("inlineCode",{parentName:"a"},"isNetworkInitialized()"))," function returns true. In addtition to routing events to specific endpoints, the network must also support broadcasting of messages during the untimed phases when INIT_BROADCAST_ADDRESS is specified as the destination. This can be done either by the SimpleNetwork object creating an event for each endpoint in the network, or the network routers can use more intelligent algorithms to guarantee that each end point receives exactly one copy of the event."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Endpoint")," ","\xa0",(0,r.kt)("br",{parentName:"p"}),"\n","Call ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," on the interface during each round of the ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," phase as SST does not automatically call this function on SubComponents. "),(0,r.kt)("h2",{id:"parameters"},"Parameters"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"phase")," (unsigned int) The phase or round number (i.e., number of times ",(0,r.kt)("inlineCode",{parentName:"li"},"init()")," has been called on all components)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"returns")," none")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"example-1-initializing-a-newtork-from-a-simplenetwork-interfaces-point-of-view"},"Example 1: Initializing a newtork, from a SimpleNetwork interface's point of view"),(0,r.kt)("p",null,"In this example, taken from the Merlin element library, the SimpleNetwork interface uses phase numbers 0-2 of ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," to perform internal initialization and allow network components to agree on network parameters. During those phase numbers, calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"isNetworkInitialized()")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". Once the network is ready, ",(0,r.kt)("inlineCode",{parentName:"p"},"isNetworkInitialized()")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", allowing the endpoints to do their own ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," protocols if needed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Excerpt from sst-elements/src/sst/elements/merlin/interfaces/linkControl.h/cc"',title:'"Excerpt',from:!0,'sst-elements/src/sst/elements/merlin/interfaces/linkControl.h/cc"':!0},"#include <sst/core/interfaces/simpleNetwork.h>\n\nLinkControl::LinkControl(...) {\n    ...\n    network_initialized = false;\n    ...\n}\n\nvoid LinkControl::init(unsigned int phase)\n{\n    /* Starting at phase=0 of init(), merlin routers and interfaces perform handshakes to determine\n     * endpoint IDs, agree on link bandwidths, and establish routing information */\n     switch ( phase ) {\n        case 0:\n            /* Start negotiating bandwidth */\n            break;\n        case 1:\n            /* Finish negotiating bandwidth and start setting up mappings for virtual networks */\n            /* Set the endpoint ID */\n            break;\n        case 2:\n            /* Set up mappings for virtual networks; other initialization activities */\n            network_initialized = true;\n            break;\n        default:\n            /* Network is initialized now, handle init() for the endpoints by sending/receiving untimed events */\n            break;\n     }\n}\n\nbool isNetworkInitialized() const { return network_initialized; }\n")),(0,r.kt)("h3",{id:"example-2-initializing-a-network-from-the-endpoints-point-of-view"},"Example 2: Initializing a network, from the endpoint's point of view"),(0,r.kt)("p",null,"During each phase of ",(0,r.kt)("inlineCode",{parentName:"p"},"init()"),", an endpoint must call ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," on a SimpleNetwork interface. It must not call any other functions on the interface until a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"isNetworkInitialized()")," returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void Endpoint::init(unsigned int phase) {\n    //highlight-next-line\n    net_iface->init(phase);\n    \n    bool networkReady = net_iface->isNetworkInitialized();\n\n    if (networkReady) {\n        /* Broadcast all the endpoint IDs so the endpoints can send data */\n        SST::Interfaces::SimpleNetwork::Request * req = new SST::Interfaces::SimpleNetwork::Request();\n        req->dest = SST::Interfaces::SimpleNetwork::INIT_BROADCAST_ADDR; /* Broadcast */\n        req->src = net_iface->getEndpointID();\n        \n        // Create an event with this endpoint's name so the other endpoints can map our ID to our name\n        SST::Interfaces::StringEvent* strEv = new SST::Interfaces::StringEvent(getName());\n        req->givePayload(strEv);\n\n        net_iface->sendUntimedData(req); \n\n        while (SST::Interfaces::SimpleNetwork::Request* req = net_iface->recvUntimedData()) {\n            /* set up a mapping table of the other endpoints' names -> IDs */\n            SST::Interfaces::StringEvent* name = static_cast<SST::Interfaces::StringEvent*>(req->takePayload());\n            IDMap.insert(std::make_pair(name->getString(), req->src));\n            delete req;\n            delete name; /* Have to delete separately from req since we used takePayload() to extract it */\n        }\n    }\n}\n")),(0,r.kt)("h2",{id:"header"},"Header"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <sst/core/interfaces/simpleNetwork.h>\n")))}m.isMDXComponent=!0}}]);
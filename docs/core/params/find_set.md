---
title: find_set
---
```cpp
template <class T>
void find_set(const std::string& key, std::set<T>& set) const;
```

Search for the specified key and return its value as a set in the provided argument `set`. The set will be empty if the key is not found. The function is parameterized on a type, `T` , which must be a valid params parameter type (e.g., numeric including bool, string, or other class with a constructor that accepts a single string).

To be interpreted as a set, a set string must adhere to a specific format. The set must be enclosed in curly braces ({}). The set values should be comma separated (commas inside single or double quotes are assumed to be a value not a delimeter). Set values themselves must be valid parameter template types. If square brackets are not used, the entire string will be assumed to be a single item in the set. The function is designed to accept the string that is generated when a Python set is passed as a parameter value in the input configuration file.

Examples of valid set strings:
* `{1, 2, 3, 4, 5}`
* `{'1', '2', '3', '4', '5'}`


## Parameters
* **key** (std::string) Parameter key to search for
* **set** (std::set<T\>) Set with type `T` to populate from the parameter's value. 
* **returns** none


## Example

<!--- SOURCE CODE: None --->
```cpp
example::example(ComponentId_t id, Params& params) : Component(id)
{
    out = new Output("", 1, 0, Output::STDOUT);

    /* Some other constructor stuff */

    /* Construct a set that is a list of neighbors' names by interpreting the paramter 'neighbors' as a set */
    std::set<std::string> neighbors;
    //highlight-next-line
    params.find_set<std::string>("neighbors", neighbors);

    out->output("Read a list of the neighbors' names. They are: \n");
    for (std::set<std::string>::iterator it = neighbors.begin(); it != neighbors.end(); it++)
    {
        out->output("%s, ", *it.c_str());
    }
    out->output("\n");
}
```

## Additional information on parsing
For those interested in a more detailed description of how this function parses a string into a set of tokens, read on. The function is tailored to the type strings you get when passing a Python set as the param string. When you call [`addParam()`](../../config/component/addParam) on a Python set in the input file, it will call the `str()` function on the set, which creates a string with the format: `{item1, item2, item3}`.

The format of the items depends on where they came from. The string for each item is generated by calling the `repr()` function on it. For strings, this means they will typically be enclosed in single quotes. It is possible that they end up enclosed in double quotes if the string itself contains a single quote. For strings which contain both single and double quotes, the `repr()` will create a single quoted string with all internal single quotes escaped with '\'. Most other items used in SST do not enclose the string in quotes, though any string that contains a comma would need to be enclosed in quotes, since the comma is the delimiter character used. This is not done automatically, so if you have something that generates a commma in the string created by `repr()`, you may need to create an a set string manually. Also, any string that starts with a quote character, must end with the same quote character.

Tokens are generated by splitting the string on commas that are not within quotes (double or single). All whitespace at the beginning and end of a token is ignored (unless inside quotes). Once the tokens are generated, any quoted string will have the front and back quotes removed. The '\' for any escaped quote of the same type as the front and back is also removed.

Examples of parsing strings using double and/or single quotes:
* 'This is "a" test' -> This is "a" test
* "This is 'a' test" -> This is 'a' test
* 'This "is \'a\'" test' -> This "is 'a''" test
* 'This "is \"a"" test' -> This "is \"a\"" test

## Header
The Params header file is included with any SST object that supports Params.
```cpp
#include <sst/core/component.h> // or
#include <sst/core/subcomponent.h> // or
#include <sst/core/componentExtension.h> // or
#include <sst/core/params.h> // if not included in base class
```